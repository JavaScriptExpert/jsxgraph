/*
    Copyright 2008, 
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.

*/

/** 
 * @fileoverview In this file the geometry object Axis is defined. Axis stores all
 * style and functional properties that are required to draw the axis on a board.
 * @author graphjs
 * @version 0.1
 */
 
/**
 * Creates a new instance of Axis.
 * @class Axis stores all style and functional properties that are required
 * to draw the axis on a board.
 * @param {Board} board Reference to the board the arc is drawn on.
 * @param {Array} p1coords The point where the axis starts
 * @param {Array} p2coords Where the axis ends.
 * @param {String} id Unique identifier for this object.  If null or an empty string is given,
 * an unique id will be generated by Board
 * @param {String} name Not necessarily unique name, displayed on the board.  If null or an
 * empty string is given, an unique name will be generated.
 * @constructor
 * @extends GeometryElement
 */
JXG.Axis = function (board, p1coords, p2coords, id, name) {
    /* Call the constructor of GeometryElement */
    this.constructor();
    this.elementClass = JXG.OBJECT_CLASS_OTHER;                
    /* Needs update only during zoom und axis translates */
    this.needsRegularUpdate = false;
    
    /**
     * Sets type of GeometryElement, value is OBJECT_TYPE_AXIS.
     * @final
     * @type int
     */
    this.type = JXG.OBJECT_TYPE_AXIS;
    /* Call init defined in GeometryElement to set board, id and name property */
    this.init(board, id, name);

    /**
     * First point defining the axis.
     * @type Point
     */
    if( JXG.IsPoint(p1coords.type) )
        this.point1 = p1coords;
    else
        this.point1 = new JXG.Point(board,p1coords,'','',false);

    /**
     * Second point defining the axis; <b>Warning:</b> If you want the axis in x (respectively y) direction
     * the y (resp x) coordinate of this point has to be the same, as the y (resp x) coordinate of point1.
     * @type Point
     */
    if( JXG.IsPoint(p2coords) )
        this.point2 = p1coords;
    else
        this.point2 = new JXG.Point(board,p2coords,'','',false);
    
    /* Make the points fixed */
    this.point1.fixed = true;
    /* Make the points fixed */
    this.point2.fixed = true;

    /**
     * This is just for the hasPoint() method. Precision for highlighting.
     * @type int
     */
    this.r = 10;
    
    /**
     * The distance between two ticks.
     * @type float
     */
    this.ticksDelta = 1;
        
    this.visProp['fillColor'] = 'none';
    this.visProp['highlightFillColor'] = 'none';
    this.visProp['visible'] = true;
    this.visProp['strokeColor'] = '#000000';
    this.visProp['strokeWidth'] = '2px';

    /**
     * Array of Coords storing the coordinates of all ticks.
     * @type Array
     * @see Coords
     */
    this.ticks = [];
    
    /* Initialise tick coordinates */
    this.updateTickCoordinates(true);

    /* Register axis at board. */
    this.id = this.board.addAxis(this);
    
    /* Add axis as child to defining points */
    this.point1.addChild(this);
    this.point2.addChild(this);
};

JXG.Axis.prototype = new JXG.GeometryElement;

/**
 * Checks whether (x,y) is near the axis.
 * @param {int} x Coordinate in x direction, screen coordinates.
 * @param {int} y Coordinate in y direction, screen coordinates.
 * @return {bool} True if (x,y) is near the axis, False otherwise.
 */
 JXG.Axis.prototype.hasPoint = function (x, y) {
    var coords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [x,y], this.board);

    var has = false;
    var i;

    var slope = this.getSlope();
    var rise = this.getRise();
     
    if(slope != "INF") {
        for(i = -this.r; i < this.r; i++) {
            has = has | (Math.abs(y - (slope*(x+i) + rise)) < this.r);
        }
        if(has) {
            var distP1P = coords.distance(JXG.COORDS_BY_SCREEN, this.point1.coords);
            var distP2P = coords.distance(JXG.COORDS_BY_SCREEN, this.point2.coords);
            var distP1P2 = this.point1.coords.distance(JXG.COORDS_BY_SCREEN, this.point2.coords);
            if((distP1P > distP1P2) || (distP2P > distP1P2)) { // P(x|y) liegt nicht zwischen P1 und P2
                if(distP1P < distP2P) { // P liegt auf der Seite von P1
                    has = false;
                }
                else { // P liegt auf der Seite von P2
                    has = false;
                }
            }
        }
    }
    else { // senkrechter Pfeil
        has = (Math.abs(x-this.point1.coords.scrCoords[1]) < this.r);
        if(has) { // sonst muss nicht weiter geprueft werden
            if(this.point1.coords.scrCoords[2] < this.point2.coords.scrCoords[2]) {
                if(y < this.point1.coords.scrCoords[2]) {
                    has = false;
                }
            }
            else if(this.point1.coords.scrCoords[2] > this.point2.coords.scrCoords[2]) {
                if(y > this.point1.coords.scrCoords[2]) {
                    has = false;
                }
            }

            if(this.point1.coords.scrCoords[2] < this.point2.coords.scrCoords[2]) {
                if(y > this.point2.coords.scrCoords[2]) {
                    has = false;
                }
            }
            else if(this.point1.coords.scrCoords[2] > this.point2.coords.scrCoords[2]) {
                if(y < this.point2.coords.scrCoords[2]) {
                    has = false;
                }
            }                  
        }
    }    

    return has;
};

/**
 * Uses the boards renderer to update the axis and all of its children.
 */
JXG.Axis.prototype.update = function () {
    if (this.needsUpdate) { 
        var p1coords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [0, 0], this.board);
        var p2coords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [this.board.canvasWidth, this.board.canvasHeight], this.board);
        if (this.point1.coords.usrCoords[2]==this.point2.coords.usrCoords[2]) {
            this.point1.coords = new JXG.Coords(JXG.COORDS_BY_USER, [p1coords.usrCoords[1], 0], this.board);
            this.point2.coords = new JXG.Coords(JXG.COORDS_BY_USER, [p2coords.usrCoords[1], 0], this.board);
        } else {
            this.point1.coords = new JXG.Coords(JXG.COORDS_BY_USER, [0,p2coords.usrCoords[2]], this.board);
            this.point2.coords = new JXG.Coords(JXG.COORDS_BY_USER, [0,p1coords.usrCoords[2]], this.board);
        }
        this.updateTickCoordinates();
    }
};

/**
 * Uses the boards renderer to update the axis and all of its children.
 */
JXG.Axis.prototype.updateRenderer = function () {
    if (this.needsUpdate) { 
        this.board.renderer.updateAxis(this);
        this.needsUpdate = false;
    }
};

/**
 * Calculates the rise of the line described by the axis.
 * @type float
 * @return The rise of the line described by the arrows defining points.
 */
JXG.Axis.prototype.getRise = function () {
    var p1scr = this.point1.coords.scrCoords;
    var p2scr = this.point2.coords.scrCoords;
                                       
    return Math.round((p1scr[2] - (p1scr[1]*(p2scr[2]-p1scr[2]))/(p2scr[1]-p1scr[1])));
};

/**
 * Calculates the slope of the line described by the arrow.
 * @type float
 * @return The slope of the line described by the arrows defining points or INF
 * if the arrow is parallel to the y-axis.
 */
JXG.Axis.prototype.getSlope = function () {
    var p1scr = this.point1.coords.scrCoords; 
    var p2scr = this.point2.coords.scrCoords;  
    
    if(Math.abs(p2scr[1]-p1scr[1]) >= 10e-6) {
       return ((p2scr[2]-p1scr[2])/(p2scr[1]-p1scr[1]));
    }
    else {
       return "INF";
    }
};

/**
 * Updates the coordinates of the axis ticks. Calls the renderer to delete old ticks
 * or create more ticks if required.
 * @param {bool} first Optional parameter, only used in constructor.
 */
JXG.Axis.prototype.updateTickCoordinates = function (first) {
    if(typeof first == 'undefined') {
        first = false;
    }
        
    var v = this.point2.coords.usrCoords[1]-this.point1.coords.usrCoords[1];
    var w = this.point2.coords.usrCoords[2]-this.point1.coords.usrCoords[2];
    var bottomRightCoords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [this.board.canvasWidth, this.board.canvasHeight], this.board);
    var topLeftCoords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [0, 0], this.board);
    var minX = Math.ceil(topLeftCoords.usrCoords[1]);
    var maxX = bottomRightCoords.usrCoords[1];
    var maxY = Math.ceil(topLeftCoords.usrCoords[2]);
    var minY = bottomRightCoords.usrCoords[2];
    
    var x,y;
    var oldTicksCount = this.ticks.length;

    for (var i=0;;i++) {
        if (v!=0) {
            x = minX+i*this.ticksDelta;
            y = 0;
            if (x>=maxX*0.95) break;
        } else {
            x = 0;
            y = minY+i*this.ticksDelta;
            if (y>=maxY*0.95) break;
        }
        this.ticks[i] = new JXG.Coords(JXG.COORDS_BY_USER, [x,y], this.board);
    }

    if(!first) {
        this.board.renderer.updateAxisTicks(this, oldTicksCount);
    }
};

JXG.createAxis = function(board, parentArr, atts) {
    // Arrays oder Punkte, mehr brauchen wir nicht.
    if ( (JXG.IsArray(parentArr[0]) || JXG.IsPoint(parentArr[0]) ) && (JXG.IsArray(parentArr[1]) || JXG.IsPoint(parentArr[1])) ) {
        el = new JXG.Axis(board, parentArr[0], parentArr[1],atts["id"],atts["name"]);
    } // Ansonsten eine fette Exception um die Ohren hauen
    else
        throw ("Can't create point with parent types '" + (typeof parentArr[0]) + "' and '" + (typeof parentArr[1]) + "'.");

    return el;
};

JXG.JSXGraph.registerElement('axis', JXG.createAxis);
