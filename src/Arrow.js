/*
    Copyright 2008, 
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.

*/

/** 
 * @fileoverview In this file the geometry object Arrow is defined. Arrow stores all
 * style and functional properties that are required to draw an arrow on a board.
 * @author graphjs
 * @version 0.1
 */
 
/**
 * Creates a new instance of Arrrow.
 * @class Arrow stores all style and functional properties that are required
 * to draw an arc on a board.
 * @param {JXG.Board} board Reference to the board the arrow is drawn on.
 * @param {JXG.Point} p1 Origin of the arrow.
 * @param {JXG.Point} p2 Defines the direction of the arrow.
 * @param {String} id Unique identifier for this object.  If null or an empty string is given,
 * an unique id will be generated by Board
 * @param {String} name Not necessarily unique name, displayed on the board.  If null or an
 * empty string is given, an unique name will be generated.
 * @see JXG.Board#addArrow
 * @constructor
 * @extends JXG.GeometryElement
 */
JXG.Arrow = function (board, p1, p2, id, name) {
    /* Call the constructor of GeometryElement */
    this.constructor();

    /**
     * Sets type of GeometryElement, value is OBJECT_TYPE_ARROW.
     * @final
     * @type int
     */
    this.type = JXG.OBJECT_TYPE_ARROW;
    
    /**
     * Class of the element, value is OBJECT_CLASS_LINE;
     */
    this.elementClass = JXG.OBJECT_CLASS_LINE;

    /* Call init defined in GeometryElement to set board, id and name property */
    this.init(board, id, name);

    /**
     * Origin of the arrow.
     * @type JXG.Point
     */
    this.point1 = JXG.GetReferenceFromParameter(board, p1);
    /**
     * Defines the direction of the arrow.
     * @type JXG.Point
     */
    this.point2 = JXG.GetReferenceFromParameter(board, p2);

    /**
     * This is just for the hasPoint() method.
     * @type int
     */
    this.r = 3;

    this.visProp['fillColor'] = 'none';
    this.visProp['highlightFillColor'] = 'none';
    this.visProp['visible'] = true;    
    
    /* Register arrow at board. */
    this.id = this.board.addArrow(this);
    
    /* Add arrow as child to defining points */
    this.point1.addChild(this);
    this.point2.addChild(this);
};

JXG.Arrow.prototype = new JXG.GeometryElement;

/**
 * Checks whether (x,y) is near the arrow.
 * @param {int} x Coordinate in x direction, screen coordinates.
 * @param {int} y Coordinate in y direction, screen coordinates.
 * @return {bool} True if (x,y) is near the arrow, False otherwise.
 */
 JXG.Arrow.prototype.hasPoint = function (x, y) {
    var coords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [x,y], this.board);

    var has = false;
    var i;

    var slope = this.getSlope();
    var rise = this.getRise();
     
    if(slope != "INF") {
        for(i = -this.r; i < this.r; i++) {
            has = has | (Math.abs(y - (slope*(x+i) + rise)) < this.r); 
        }
        if(has) {
            var distP1P = coords.distance(JXG.COORDS_BY_SCREEN, this.point1.coords);
            var distP2P = coords.distance(JXG.COORDS_BY_SCREEN, this.point2.coords);
            var distP1P2 = this.point1.coords.distance(JXG.COORDS_BY_SCREEN, this.point2.coords);
            if((distP1P > distP1P2) || (distP2P > distP1P2)) { // P(x|y) liegt nicht zwischen P1 und P2
                if(distP1P < distP2P) { // P liegt auf der Seite von P1
                    has = false;
                } else { // P liegt auf der Seite von P2
                    has = false;
                }
            }
        }
    } else { // senkrechter Pfeil
        has = (Math.abs(x-this.point1.coords.scrCoords[1]) < this.r);
        if(has) { // sonst muss nicht weiter geprueft werden
            if(this.point1.coords.scrCoords[2] < this.point2.coords.scrCoords[2]) {
                if(y < this.point1.coords.scrCoords[2]) {
                    has = false;
                }
            } else if(this.point1.coords.scrCoords[2] > this.point2.coords.scrCoords[2]) {
                if(y > this.point1.coords.scrCoords[2]) {
                    has = false;
                }
            }

            if(this.point1.coords.scrCoords[2] < this.point2.coords.scrCoords[2]) {
                if(y > this.point2.coords.scrCoords[2]) {
                    has = false;
                }
            }
            else if(this.point1.coords.scrCoords[2] > this.point2.coords.scrCoords[2]) {
                if(y < this.point2.coords.scrCoords[2]) {
                    has = false;
                }
            }                  
        }
    }    

    return has;
};

/**
 * Uses the boards renderer to update the arrow and all of its children.
 * update() is not needed
 */
 JXG.Arrow.prototype.updateRenderer = function () {
    if (this.needsUpdate) {
        this.board.renderer.updateArrow(this);
        this.needsUpdate = false;
    }
};

/**
 * Calculates the rise of the line described by the arrow.
 * @type float
 * @return The rise of the line described by the arrows defining points.
 */
JXG.Arrow.prototype.getRise = function () {
    var p1scr = this.point1.coords.scrCoords;
    var p2scr = this.point2.coords.scrCoords;
                                       
    return Math.round((p1scr[2] - (p1scr[1]*(p2scr[2]-p1scr[2]))/(p2scr[1]-p1scr[1])));
};

/**
 * Calculates the slope of the line described by the arrow.
 * @type float
 * @return The slope of the line described by the arrows defining points or INF
 * if the arrow is parallel to the y-axis.
 */
JXG.Arrow.prototype.getSlope = function () {
    var p1scr = this.point1.coords.scrCoords; 
    var p2scr = this.point2.coords.scrCoords;  
    
    if(Math.abs(p2scr[1]-p1scr[1]) >= 10e-6) {
       return ((p2scr[2]-p1scr[2])/(p2scr[1]-p1scr[1]));
    }
    else {
       return "INF";
    }
};

/**
 * Calculates the anchor coordinates for the text element.
 * @type JXG.Coords
 * @return Anchor coordinates for text element.
 */
JXG.Arrow.prototype.getTextAnchor = function() {
    return new JXG.Coords(JXG.COORDS_BY_USER, [0.5*(this.point2.X() - this.point1.X()),0.5*(this.point2.Y() - this.point1.Y())],this.board);
};

/**
 * Copy the element to the background.
 * @param {bool} addToTrace Not used.
 */
JXG.Arrow.prototype.cloneToBackground = function(addToTrace) {
    var copy = {};
    copy.id = this.id + 'T' + this.numTraces;
    this.numTraces++;
    copy.point1 = this.point1;
    copy.point2 = this.point2;
    copy.visProp = this.visProp;
    
    this.board.renderer.drawArrow(copy);
    this.traces[copy.id] = $(copy.id);

    delete copy;
};

/**
 * Provide update method.
 */
JXG.Arrow.prototype.update = function() {    
    if (this.needsUpdate) {
        this.updateStdform();
    }
};

/**
 * Provide update method.
 */
JXG.Arrow.prototype.updateStdform = function() {    
    var nx = -(this.point2.coords.usrCoords[2]-this.point1.coords.usrCoords[2]);
    var ny =  this.point2.coords.usrCoords[1]-this.point1.coords.usrCoords[1];
    var c = -(nx*this.point1.coords.usrCoords[1]+ny*this.point1.coords.usrCoords[2]);

    this.stdform[0] = c;
    this.stdform[1] = nx;
    this.stdform[2] = ny;
    this.stdform[3] = 0;

    this.normalize();
};

/**
 * Creates a new arrow.
 * @param {JXG.Board} board The board the arrow is put on.
 * @param {Array} parents Array of two points defining the arrow.
 * @param {Object} attributs Object containing properties for the element such as stroke-color and visibility. See @see JXG.GeometryElement#setProperty
 * @type JXG.Arrow
 * @return Reference to the created arrow object.
 */
JXG.createArrow = function(board, parents, attributes) {
    var el;
    
    if ( (JXG.IsPoint(parents[0])) && (JXG.IsPoint(parents[1])) ) {
        el = new JXG.Arrow(board, parents[0], parents[1], attributes['id'], attributes['name']);
    } // Ansonsten eine fette Exception um die Ohren hauen
    else
        throw ("Can't create arrow with parent types '" + (typeof parents[0]) + "' and '" + (typeof parents[1]) + "'.");

    return el;
};

JXG.JSXGraph.registerElement('arrow', JXG.createArrow);