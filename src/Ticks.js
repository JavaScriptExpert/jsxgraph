/*
    Copyright 2008,2009
        Matthias Ehmann,
        Michael Gerhaeuser,
        Carsten Miller,
        Bianca Valentin,
        Alfred Wassermann,
        Peter Wilfahrt

    This file is part of JSXGraph.

    JSXGraph is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    JSXGraph is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with JSXGraph.  If not, see <http://www.gnu.org/licenses/>.
*/

/** 
 * @fileoverview In this file the geometry object Ticks is defined. Ticks provides
 * methods for creation and management of ticks on an axis.
 * @author graphjs
 * @version 0.1
 */
 
/**
 * Creates a new instance of Ticks.
 * @class Ticks provides methods for creation and management
 * of ticks on an axis.
 * @param {JXG.Line} line Reference to the board the arc is drawn on.
 * @param {Array/Function} ticks Array or function defining the ticks.
 * @param {String} multiplier A string that will be appended to every ticks label.
 * @param {String} id Unique identifier for this object.  If null or an empty string is given,
 * an unique id will be generated by Board
 * @param {String} name Not necessarily unique name, displayed on the board.  If null or an
 * empty string is given, an unique name will be generated.
 * @see JXG.Board#addArc
 * @constructor
 * @extends JXG.GeometryElement
 */
JXG.Ticks = function (line, ticks, multiplier, id, name) {
    /* Call the constructor of GeometryElement */
    this.constructor();
    
    /**
     * Type of GeometryElement, value is OBJECT_TYPE_ARC.
     * @final
     * @type int
     */
    this.type = JXG.OBJECT_TYPE_TICKS;
    
    /**
     * Class of the element, value is OBJECT_CLASS_CIRCLE.
     * @final
     * @type int
     */
    this.elementClass = JXG.OBJECT_CLASS_LINE;
    
    /**
     * The line the ticks belong to.
     * @type JXG.Line
     */
    this.line = line;
    
    /**
     * The board the ticks line is drawn on.
     * @type JXG.Board
     */
    this.board = this.line.board;
    
    /**
     * A function calculating ticks delta depending on the ticks number.
     * @type Function
     */
    this.ticksFunction = null;
    
    /**
     * Array of fixed ticks.
     * @type Array
     */
    this.fixedTicks = null;
    
    if(JXG.IsFunction(ticks))
        this.ticksFunction = ticks;
    else
        this.fixedTicks = ticks;
    
    /**
     * A string appended to any ticks label.
     */
    this.multiplier = (multiplier == null ? '' : multiplier);
    
    /**
     * Draw the zero tick, that lies at line.point1?
     * @type bool
     */
    this.drawZero = true;

    /* Call init defined in GeometryElement to set board, id and name property */
    this.init(this.board, id, name);

    this.visProp['visible'] = true;
    
    this.visProp['fillColor'] = this.line.visProp['fillColor'];
    this.visProp['highlightFillColor'] = this.line.visProp['highlightFillColor'];
    this.visProp['strokeColor'] = this.line.visProp['strokeColor'];
    this.visProp['highlightStrokeColor'] = this.line.visProp['highlightStrokeColor'];     
    
    /* Register ticks at line. */
    this.id = this.line.addTicks(this);
};

JXG.Ticks.prototype = new JXG.GeometryElement;

/**
 * Always returns false.
 * @param {int} x Coordinate in x direction, screen coordinates.
 * @param {int} y Coordinate in y direction, screen coordinates.
 * @return {bool} Always returns false.
 */
JXG.Ticks.prototype.hasPoint = function (x, y) { 
   return false;
};

/**
 * (Re-)calculates the ticks coordinates.
 */
JXG.Ticks.prototype.calculateTicksCoordinates = function() {
    // calculate start (c1) and end (c2) points
    // copy existing lines point coordinates
    var c1 = new JXG.Coords(JXG.COORDS_BY_USER, [this.line.point1.coords.usrCoords[1], this.line.point1.coords.usrCoords[2]], this.board);
    var c2 = new JXG.Coords(JXG.COORDS_BY_USER, [this.line.point2.coords.usrCoords[1], this.line.point2.coords.usrCoords[2]], this.board);
    
    // now let the renderer calculate start and end point of the line on the board, i.e.
    // intersection points of line with the boards edges in the case that the line is a straight.
    this.board.renderer.calcStraight(this.line, c1, c2);
    var p1 = this.line.point1.coords;

    this.ticks = new Array();
    this.labels = new Array();

    if(this.ticksFunction != null) {
        // calculate ticks
        // between start point (c1) and this.line.point1

        // distance between start and end points
        var dx = p1.usrCoords[1]-c1.usrCoords[1]; // delta x
        var dy = p1.usrCoords[2]-c1.usrCoords[2]; // delta y
    
        var ticksDelta = 0;
        var total_length = Math.sqrt(dx*dx + dy*dy);
    
        var x = p1.usrCoords[1];
        var y = p1.usrCoords[2];
    
        // add tick at p1?
        if(this.drawZero) {
            this.ticks.push(new JXG.Coords(JXG.COORDS_BY_USER, [x,y], this.board));
            this.labels.push('0');
        }

        var i = -1;
        ticksDelta = Math.abs(this.ticksFunction(i));
        var position = -ticksDelta;

        var deltaX = (ticksDelta * dx) / (total_length);
        var deltaY = (ticksDelta * dy) / (total_length);
    
        //alert(ticksDelta + " : " + dx + " : " + total_length + " : " + deltaX + " : " + x + " : " + c1.usrCoords[1]);

        while( ((this.board.sgn(deltaX)*(x-deltaX) >= this.board.sgn(deltaX)*c1.usrCoords[1]) && (this.board.sgn(deltaY)*(y-deltaY) >= this.board.sgn(deltaY)*c1.usrCoords[2])) ) {
            x = x - deltaX;
            y = y - deltaY;

            this.ticks.push(new JXG.Coords(JXG.COORDS_BY_USER, [x,y], this.board));
            this.labels.push(position + '' + this.multiplier);

            i = i-1;
            ticksDelta = Math.abs(this.ticksFunction(i));
            position = position - ticksDelta;

            deltaX = (ticksDelta * dx) / (total_length);
            deltaY = (ticksDelta * dy) / (total_length);
        }


        // between end point (c2) and this.point1

        // distance between start and end points
        dx = p1.usrCoords[1]-c2.usrCoords[1]; // delta x
        dy = p1.usrCoords[2]-c2.usrCoords[2]; // delta y

        total_length = Math.sqrt(dx*dx + dy*dy);

        // reset start coordinates
        x = p1.usrCoords[1];
        y = p1.usrCoords[2];

        i = 1;
        ticksDelta = Math.abs(this.ticksFunction(i));
        position = ticksDelta;

        deltaX = (ticksDelta * dx) / (total_length);
        deltaY = (ticksDelta * dy) / (total_length);

        while( ((this.board.sgn(deltaX)*(x-deltaX) >= this.board.sgn(deltaX)*c2.usrCoords[1]) && (this.board.sgn(deltaY)*(y-deltaY) >= this.board.sgn(deltaY)*c2.usrCoords[2])) ) {
            x = x - deltaX;
            y = y - deltaY;

            this.ticks.push(new JXG.Coords(JXG.COORDS_BY_USER, [x,y], this.board));
            this.labels.push(position + '' + this.multiplier);

            i = i+1;
            ticksDelta = Math.abs(this.ticksFunction(i));
            position = position + ticksDelta;

            deltaX = (ticksDelta * dx) / (total_length);
            deltaY = (ticksDelta * dy) / (total_length);
        }
    } else {
        // we have an array of fixed ticks we have to draw
        var dx_minus = p1.usrCoords[1]-c1.usrCoords[1];
        var dy_minus = p1.usrCoords[2]-c1.usrCoords[2];
        var length_minus = Math.sqrt(dx_minus*dx_minus + dy_minus*dy_minus);

        var dx_plus = p1.usrCoords[1]-c2.usrCoords[1];
        var dy_plus = p1.usrCoords[2]-c2.usrCoords[2];
        var length_plus = Math.sqrt(dx_plus*dx_plus + dy_plus*dy_plus);
        
        // new ticks coordinates
        var nx = 0;
        var ny = 0;
        
        for(var j=0; j<this.fixedTicks.length; j++) {
            // is this tick visible?
            if((-length_minus <= this.fixedTicks[j]) && (this.fixedTicks[j] <= length_plus)) {
                if(this.fixedTicks[j] < 0) {
                    nx = -Math.abs(dx_minus) * this.fixedTicks[j]/length_minus;
                    ny = -Math.abs(dy_minus) * this.fixedTicks[j]/length_minus;
                } else {
                    nx = Math.abs(dx_plus) * this.fixedTicks[j]/length_plus;
                    ny = Math.abs(dy_plus) * this.fixedTicks[j]/length_plus;
                }
                
                this.ticks.push(new JXG.Coords(JXG.COORDS_BY_USER, [nx, ny], this.board));
                this.labels.push(this.fixedTicks[j] + '' + this.multiplier);
            }
        }
    }
    
    // this piece of code was in AbstractRenderer.updateAxisTicksInnerLoop
    // and has been moved in here to clean up the code.
    var eps = 0.00001;
    var slope = -this.line.getSlope();
    var dist = 3*this.line.r / 2;
    dx = 0; dy = 0;
    
    if(Math.abs(slope) < eps) {
        // if the slope of the line is (almost) 0, we can set dx and dy directly
        dx = 0;
        dy = dist;
    } else if((Math.abs(slope) > 1/eps) || (isNaN(slope))) {
        // if the slope of the line is (theoretically) infinite, we can set dx and dy directly
        dx = dist;
        dy = 0;
    } else {
        // here we have to calculate dx and dy depending on the slope and the length of the tick (dist)
        // if slope is the line's slope, the tick's slope is given by
        // 
        //            1          dy
        //     -   -------  =   ----                 (I)
        //          slope        dx
        //
        // when dist is the length of the tick, using the pythagorean theorem we get
        // 
        //     dx*dx + dy*dy = dist*dist             (II)
        //
        // dissolving (I) by dy and applying that to equation (II) we get the following formulas for dx and dy
        dx = dist/Math.sqrt(1/(slope*slope) + 1);
        dy = -dx/slope;
    }
    this.board.renderer.updateTicks(this,dx,dy);
};

/**
 * Uses the boards renderer to update the arc.
 * update() is not needed for arc.
 */
 JXG.Ticks.prototype.updateRenderer = function () {
    if (this.needsUpdate) { 
        this.calculateTicksCoordinates();
        this.needsUpdate = false;
    }
};

/**
 * Creates a new arc.
 * @param {JXG.Board} board The board the ticks are put on.
 * @param {Array} parents Array containing a line and an array of positions, where ticks should be put on that line or
 *   a function that calculates the distance based on the ticks number that is given as a parameter. E.g.:<br />
 *   <tt>var ticksFunc = function(i) {</tt><br />
 *   <tt>    return 2;</tt><br />
 *   <tt>}</tt><br />
 *   for ticks with distance 2 between each tick.
 * @param {Object} attributs Object containing properties for the element such as stroke-color and visibility. See @see JXG.GeometryElement#setProperty
 * @type JXG.Arc
 * @return Reference to the created arc object.
 */
JXG.createTicks = function(board, parents, attributes) {
    var el;
    // Alles 3 Punkte?
    if ( (parents[0].elementClass == JXG.OBJECT_CLASS_LINE) && (JXG.IsFunction(parents[1]) || JXG.IsArray(parents[1]))) {
        el = new JXG.Ticks(parents[0], parents[1], attributes['multiplier'], attributes['id'], attributes['name']);
    } // Ansonsten eine fette Exception um die Ohren hauen
    else
        throw ("Can't create Ticks with parent types '" + (typeof parents[0]) + "' and '" + (typeof parents[1]) + "' and '" + (typeof parents[2]) + "'.");

    return el;
};

JXG.JSXGraph.registerElement('ticks', JXG.createTicks);