/** 
 * @fileoverview In this file the class Group is defined, a class for
 * managing grouping of points.
 * @author graphjs
 * @version 0.1
 */
 
/**
 * Creates a new instance of Group.
 * @class In this class all group management is done.
 * @param {String} id Unique identifier for this object.  If null or an empty string is given,
 * an unique id will be generated by Board
 * @param {String} name Not necessarily unique name, displayed on the board.  If null or an
 * empty string is given, an unique name will be generated.
 * @constructor
 */
JXG.Group = function(board, id, name) {
    this.board = board;
    this.objects = {};

    var number = this.board.numObjects;
    this.board.numObjects++;

    if((id == '') || (id == null) || (typeof id == 'undefined')) {
        this.id = this.board.id + 'Group' + number;
    } else {
        this.id = id;
    }
    
    this.type = JXG.OBJECT_TYPE_POINT;
    this.elementClass = JXG.OBJECT_CLASS_POINT;                

    if((name == '') || (name == null) || (typeof name == 'undefined')) {
        this.name = 'group_' + this.board.generateName(this);
    } else {
        this.name = name;
    }
    delete(this.type);

    var objArray;
    if( (arguments.length == 4) && (Object.isArray(arguments[3])) )
        objArray = arguments[3];
    else {
        objArray = [];
        for(var i=3; i<arguments.length; i++) {
            objArray.push(arguments[i]);
        }
    }

    for (var i=0; i<objArray.length; i++) {
        var obj = JXG.GetReferenceFromParameter(this.board, objArray[i]);
        if( (!obj.fixed) && ( (obj.type == JXG.OBJECT_TYPE_POINT) || (obj.type == JXG.OBJECT_TYPE_GLIDER) ) ) {
            if(obj.group.length != 0) {
                this.addGroup(obj.group[obj.group.length-1]);
            } else {
                this.addPoint(obj);
            }
        }
    }
    
    for(var el in this.objects) {
        this.objects[el].group.push(this);
    }

    this.dX = 0;
    this.dY = 0;
};

/**
 * Releases the group added to the points in this group, but only if this group is the last group.
 */
JXG.Group.prototype.ungroup = function() {
    for(var el in this.objects) {
        if(this.objects[el].group[this.objects[el].group.length-1] == this) {
            this.objects[el].group.pop();
        }
        
        delete(this.objects[el]);
    }
};

/**
 * Sends an update to all group members.
 * @param {Point} point The point that caused the update.
 */
JXG.Group.prototype.update = function(point) {
    var obj = null;
    
    for(var Elements in this.objects) {
        obj = this.objects[Elements];
        if(obj.id != point.id) {
            obj.coords = new JXG.Coords(JXG.COORDS_BY_SCREEN, [obj.coords.scrCoords[1] + this.dX, obj.coords.scrCoords[2] + this.dY], obj.board);
        }
    }
    
    for(var Elements in this.objects) {
        /* Wurde das Element vielleicht geloescht? */
        if(this.board.objects[Elements] != undefined) {
            /* Nein, wurde es nicht, also updaten */
            this.objects[Elements].update(false);
        } else { /* es wurde geloescht, also aus dem Array entfernen */
            delete(this.objects[Elements]);
        }
    }
};

/**
 * Adds an Point to this group.
 * @param {Point} object The object added to the group.
 */
JXG.Group.prototype.addPoint = function(object) {
    this.objects[object.id] = object;
};

/**
 * Adds an multiple points to this group.
 * @param {Array} objects An array of points to add to the group.
 */
JXG.Group.prototype.addPoints = function(objects) {
    for(var p in objects)
        this.objects[p.id] = p;
};

/**
 * Adds an Pint to this group.
 * @param {Point} object The object added to the group.
 */
JXG.Group.prototype.addGroup = function(group) {
    for(var el in group.objects) {
        this.addPoint(group.objects[el]);
    }
};
