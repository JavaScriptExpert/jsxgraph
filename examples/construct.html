<html>
<head>
   <title>JSXGraph example</title>
   <link rel="stylesheet" type="text/css" href="../distrib/jsxgraph.css" />
    <script type="text/javascript" src="../src/loadjsxgraph.js"></script>
</head>
<body>
<h1>Playground</h1>
<!-- Drawing area -->
<div id="jxgbox" class="jxgbox" style="width:800px; height:800px; overflow:hidden;"></div>
<!-- Drawing area -->
<div id="debug" style="display:block;"></div>
<script type="text/javascript">
/* <![CDATA[ */
JXG.Options.showCopyright = true; //don't work :)
JXG.Options.showNavigation = true;
//JXG.Options.takeFirst = true;
var board = JXG.JSXGraph.initBoard('jxgbox', {originX: 400,originY: 400, unitX: 10, unitY: 10, axis:true});
var A=board.create('point',[10,0]);
var B=board.create('point',[0,0]);
var C=board.create('point',[0,10]);

var D=board.create('point',[-5,10]);
var E=board.create('point',[-5,-5]);

/*
var createArc = function(board,parents,attributes) {
    var A = parents[0],
        B = parents[1],
        C = parents[2],
        defaults, att, options,
        c;
        
    // Read the default values from Options and use them in case they are not set by the user
    // in attributes
    defaults = {withLabel:false, layer:null};
    defaults['strokeWidth'] =  board.options.elements['strokeWidth'];
    options = board.options.arc;
    for (att in options) {
        defaults[att] = options[att];
    }
    
    attributes = JXG.checkAttributes(attributes, defaults);
        
    c = board.create('curve',[[0],[0]],attributes);
    c.updateDataArray = function() {
        var beta, co, si, matrix,
            phi = this.board.algebra.rad(A,B,C),
            n = 100, i,
            delta = phi/n, //Math.PI/90.0,
            x = B.X(),
            y = B.Y(),
            v;
        this.dataX = [A.X()];
        this.dataY = [A.Y()];
        
        for (beta=delta,i=1; i<=n; i++, beta+=delta) {
            co = Math.cos(beta); 
            si = Math.sin(beta); 
            matrix = [[1,            0,   0],
                      [x*(1-co)+y*si,co,-si],
                      [y*(1-co)-x*si,si, co]];    
            v = JXG.Math.matVecMult(matrix,A.coords.usrCoords);
            this.dataX.push(v[1]/v[0]);
            this.dataY.push(v[2]/v[0]);
        }
    };
    board.update(c);
    return c;
};

var createSector = function(board,parents,attributes) {
    var A = parents[0],
        B = parents[1],
        C = parents[2], 
        defaults, att, options,
        c;
    
    // Read the default values from Options and use them in case they are not set by the user
    // in attributes
    defaults = {withLabel:false, layer:null};
    defaults['strokeWidth'] =  board.options.elements['strokeWidth'];
    options = board.options.sector;
    for (att in options) {
        defaults[att] = options[att];
    }
    
    attributes = JXG.checkAttributes(attributes, defaults);
        
    c = board.create('curve',[[0],[0]],attributes);
    c.updateDataArray = function() {
        var beta, co, si, matrix,
            phi = this.board.algebra.rad(A,B,C),
            n = 100, i,
            delta = phi/n, //Math.PI/90.0,
            x = B.X(),
            y = B.Y(),
            v;
        this.dataX = [B.X(),A.X()];
        this.dataY = [B.Y(),A.Y()];
        
        for (beta=delta,i=1; i<=n; i++, beta+=delta) {
            co = Math.cos(beta); 
            si = Math.sin(beta); 
            matrix = [[1,            0,   0],
                      [x*(1-co)+y*si,co,-si],
                      [y*(1-co)-x*si,si, co]];    
            v = JXG.Math.matVecMult(matrix,A.coords.usrCoords);
            this.dataX.push(v[1]/v[0]);
            this.dataY.push(v[2]/v[0]);
        }
        this.dataX.push(B.X());
        this.dataY.push(B.Y());
    };
    board.update(c);
    return c;
};
*/

board.create('arc',[B,A,C],{withLabel:true,name:'Arc'}).setProperty({firstArrow:true});

//board.create('circle',[B,A],{strokeColor:'red'});
//board.create('sector',[B,D,E],{});
//board.create('semicircle',[D,E],{withLabel:true,name:'Semicircle'});
board.create('circumcirclesector',[B,C,E],{withLabel:true,name:'circumcircle'});


/*
var img = board.create('image',['http://www.ari.uni-heidelberg.de/gaia/gallery/GR/gr0283-01.artistic-Gaia-Galaxy-large.jpg',[-40,-40],[80,80]]);
img.needsRegularUpdate = false;
var p_1 = board.create('point',[-1,0],{name:'Circle1',style:10});
var el_1 = board.create('circle',[p_1,3.0], {fillColor:'#aa0000', strokeColor:'#00ff00',strokeWidth:1,fillOpacity:0.5});
var p_2 = board.create('point',[0,0], {name:'Circle2',style:10});
var el_2 = board.create('circle',[p_2,3.0],{fillColor:'#aa0000', strokeColor:'#00ff00',strokeWidth:1,fillOpacity:0.5}); 
p_1.moveTo([8,8]);
*/


/*

JXG.Options.point.zoom=true;
var board = JXG.JSXGraph.initBoard('jxgbox', {boundingbox:[-7,5,7,-5], grid:true,axis:true,keepaspectratio:true});
var p1 = board.createElement('point',[1,1], {name:'A',style:6});
var p2 = board.createElement('point',[5,2], {name:'B',face:'[]'});
var p3 = board.createElement('point',[0,-1], {name:'C',face:'x'});
var p4 = board.createElement('point',[5,3], {name:'D',style:6, trace:true});
var f = board.createElement('functiongraph', [function(x){return Math.cos(x);},0,Math.PI*2]);
var circ = board.createElement('circle', [p1,p2], {dash:1,fillColor:'yellow',fillOpacity:1.0});
var ac = board.createElement('glider', [0,2,circ],{name:'S'} );
var t = board.createElement('normal',[ac], {dash:3,strokeColor:'black'});
var t = board.createElement('normal',[p2,circ], {dash:3,strokeColor:'black'});
*/
/*
    
    var f = function(t){return p2.Y()*t*Math.sin(t);};
    var g = function(t){return t;};
    var c = board.createElement('functiongraph', [f]);
    var c1 = board.createElement('curve', [function(t){ return t-Math.sin(t);},function(t){ return t-Math.cos(t);}] );
    var p = board.createElement('glider', [0.1,2,circ],{name:'S'} );
    var t = board.createElement('tangent',[p], {dash:3,strokeColor:'red'});
    var t = board.createElement('normal',[p,t], {dash:3,strokeColor:'black'});

    var p3 = board.createElement('glider', [function(){return p1.X();},function(){return f(p1.X());},c],{fixed:true});
    var t = board.createElement('tangent',[p3], {dash:3,strokeColor:'red'});
    var p4 = board.createElement('glider', [c]);
    board.createElement('circle', [p3,p2,p1], {dash:5,strokeColor:'black'} );
/*    
*/    
/*
        var p = [];
        p[0] = board.createElement('point', [-1,-2], {style:4});
        p[1] = board.createElement('point', [6,5], {style:4});
        p[2] = board.createElement('point', [-0.5,1], {style:4});
        p[3] = board.createElement('point', [3,3], {style:4});
        var f = board.lagrangePolynomial(p);
    var graph = board.createElement('functiongraph', [f, -10, 10]);
 
    var g = function(x) {
         return board.D(f)(x)-(p[1].Y()-p[0].Y())/(p[1].X()-p[0].X());
        }
 
    var r = board.createElement('glider', [
                    function() { return board.root(g,(p[0].X()+p[1].X())*0.5); },
                    function() { return f(board.root(g,(p[0].X()+p[1].X())*0.5)); }, graph], 
         {name:' ',style:6});
tang = board.createElement('tangent',[r],{strokeColor:'#ff0000',dash:1});
line = board.createElement('line',[p[0],p[1]],{strokeColor:'#ff0000',dash:1});
*/
/*
    // Ellipse
    board.createElement('curve', 
        [
            //"X(A)*Sin(t)","Y(A)*Cos(t)",
            function(t){return p2.X()*Math.sin(t)},
            function(t){return p2.Y()*Math.cos(t)},
            0, 2*Math.PI
        ], 
        { strokeWidth:1 });
    
    // Constraint points
    board.createElement('point',['X(B)+0.5','Y(B)'],{ visible:true, name:"Y"});
    board.createElement('point',
        [
            function(){return p2.X()*2/3+p1.X()/3;},
            function(){return p2.Y()*2/3+p1.Y()/3;}
        ],
        { visible:true, name:"1/3", style:9}
    );

    // Glider: two possibilities
    var s1 = board.createElement('glider',[0, 0, l]); // On line l
    var s2 = board.createElement('point',[0, 0], {slideObject: c.id}); // On circle
   
    testmakro(board,s1,s2); 
*/
     
/* ]]> */
</script>
</body>
</html>
