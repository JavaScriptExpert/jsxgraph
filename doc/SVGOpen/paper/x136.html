<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Implementation details</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
HREF="index.html"><LINK
REL="UP"
HREF="t2.html"><LINK
REL="PREVIOUS"
TITLE="Using JSXGraph with a connection to a server"
HREF="x133.html"><LINK
REL="NEXT"
TITLE="Bibliography"
HREF="b189.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x133.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="b189.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN136"
>8. Implementation details</A
></H1
><P
>&#13;            The main focus of JSXGraph is on interactivity. The user should experience immediate response to the dragging of points
            with the mouse. So, special care had to be spent on fast reacting to the mouse move events and mouse up events. Contrarily
            we want to exploit the superb output quality of vector graphics. These two controversial goals - 
            speed versus quality - have to be balanced. 
        </P
><P
>&#13;            For the browser abstraction JSXGraph uses either the Prototype JavaScript library<A
NAME="AEN140"
HREF="#FTN.AEN140"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
> 
            or 
            jQuery<A
NAME="AEN143"
HREF="#FTN.AEN143"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>.  
            JSXGraph can be used with either of these two libraries equally good. 
            The access to these libraries is restricted to a minimum and it is capsuled in a few lines in the
            source code file jsxgraph.js. These libraries are nerly exclusively used for the corss-browser handling of events.
            Everything else in JSXGraph is built up from scratch and does not rely on third-party libraries.
            So, it should be easy to port JSXGraph to a further framework, if necessary.
        </P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN146"
>8.1. SVG vs. VML</A
></H2
><P
>&#13;                One of the major user audiences of JSXGraph are schools. In general, schools are adapting only slowly to new technologies.
                That is one of the reason, why Internet Explorer is widely used in schools. Since we can not afford to exclude schools as
                users of JSXGraph we had to adapt it to the Internet Explorer, too. Since the year 1998 
                Microsoft<A
NAME="AEN149"
HREF="#FTN.AEN149"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
> <A
HREF="b189.html#AEN203"
><ABBR
CLASS="abbrev"
>VML1998</ABBR
></A
>
                supports VML 
                - vector markup language - as vector graphic language in the Internet Explorer. 
                Early in the development process of JSXGraph we decided to support SVG and VML directly, without using one of their
                existing abstraction layers. The reason was performance, the existing layers were too slow at that time.
            </P
><P
>&#13;                SVG and VML are similar in many aspects, but different in many details. In order to realize visual properties VML makes heavily use of
                subnodes of XML nodes. SVG uses mostly attributes for the same visual properties.
                But overall the differences are not too large. The JSXGraph source contains two files SVGRenderer.js and VMLRenderer.js which handle 
                different language features. Each file consists of about 700 lines including comments.
            </P
><P
>&#13;                In SVG JSXGraph rarely uses CSS formatting.  The reason is that in the beginning of the development process
                the use of CSS styles consumed to much computing resources, especially setting opacity with Firefox. 
                So, nearly all visual properties are realized with attributes and filters. But filters in SVG are still not 
                implemented satisfactorily. Since version 0.76 JSXGraph supports shadows and gradients. 
                The SVG filter to display lines, circles and points with shadows is implemented dynamically with the following
                commands. 
                <PRE
CLASS="programlisting"
>&#13;    this.defs = this.container.ownerDocument.createElementNS(this.svgNamespace,'defs');
    this.svgRoot.appendChild(this.defs);
    this.filter = this.container.ownerDocument.createElementNS(this.svgNamespace,'filter');
    this.filter.setAttributeNS(null, 'id', 'f1');
    this.filter.setAttributeNS(null, 'width', '300%');
    this.filter.setAttributeNS(null, 'height', '300%');
    this.feOffset = this.container.ownerDocument.createElementNS(this.svgNamespace,'feOffset');
    this.feOffset.setAttributeNS(null, 'result', 'offOut');
    this.feOffset.setAttributeNS(null, 'in', 'SourceAlpha');
    this.feOffset.setAttributeNS(null, 'dx', '5');
    this.feOffset.setAttributeNS(null, 'dy', '5');
    this.filter.appendChild(this.feOffset);
    this.feGaussianBlur = this.container.ownerDocument.createElementNS(this.svgNamespace,'feGaussianBlur');
    this.feGaussianBlur.setAttributeNS(null, 'result', 'blurOut');
    this.feGaussianBlur.setAttributeNS(null, 'in', 'offOut');
    this.feGaussianBlur.setAttributeNS(null, 'stdDeviation', '3');
    this.filter.appendChild(this.feGaussianBlur);
    this.feBlend = this.container.ownerDocument.createElementNS(this.svgNamespace,'feBlend');
    this.feBlend.setAttributeNS(null, 'in', 'SourceGraphic');
    this.feBlend.setAttributeNS(null, 'in2', 'blurOut');
    this.feBlend.setAttributeNS(null, 'mode', 'normal');
    this.filter.appendChild(this.feBlend);
    this.defs.appendChild(this.filter);</PRE
>
                At the time of writing shadows slow down the browser considerably on the Firefox. Further, there seems to be a bug for
                horizontal and vertical lines. In these cases no shadows are displayed.
                In Webkit based browsers like Chrome and Safari these filters are not implemented, yet. In Opera it looks ugly.
                VML realizes shadows as a subnode. There, no noticable speed reduction is observable.
            </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN156"
>8.2. HTML elements</A
></H2
><P
>&#13;                For the display of text, like labels of points or results of computations, JSXGraph does not use the text element of SVG.
                Instead, div tags in HTML are used. That means the browsers display the text as HTML elements above the SVG image. 
                In order to update the text the innerHTML property of HTML is used. This is slow, but since many texts are never changed,
                it is used rarely.
                We decided to use HTML elements for SVG, because 
                <P
></P
><UL
><LI
>at that time HTML tags and HTML entities in texts were not supported 
                        in the Firefox implementation, 
                        </LI
><LI
>VML does not contain a text  element. Therefore, we do not need to distinguish SVG and VML 
                        for texts.
                        </LI
></UL
>
            </P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN162"
>8.3. Speed improvements</A
></H2
><P
>&#13;                In order to make a fast enough reaction to user interaction like mouse move possible, JSXGraph contains many 
                tricks to speed up the computations. Special care about implementation details is still necessary, even if the
                JavaScript interpreters, respectively Just-in-time-compilers, have made huge progress since the development of JSXGraph 
                has been started.
                Here, we list a few of the tricks of the trade, which proved to be useful. Of course, the benefits 
                of most of these tricks depend on the browser implementations and may change with new versions of the browsers.
            </P
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN165"
>8.3.1. Avoid DOM accesses with getElementById()</A
></H3
><P
>When a new SVG node is created, a reference to the DOM node 
                    is safed internally. Later on, access to this node is realized via this pointer variable, exclusively.
                    Using getElementById() or the $() operator of prototype.js or jquery.js proved to be much too slow.
                 </P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN168"
>8.3.2. Suspend the update of SVG nodes</A
></H3
><P
>&#13;                        Before a construction is updated, triggered by a mouse move or mouse up event, the redrawing 
                        of the SVG nodes is suspended, until the position of all elements has been recalculated.
                        Then, the redrawing of the SVG nodes is forced.
                <PRE
CLASS="programlisting"
>&#13;    this.suspendHandle = this.svgRoot.suspendRedraw(10000);
    // Expensive recalculations ...
    this.svgRoot.unsuspendRedraw(this.suspendHandle);
    this.svgRoot.forceRedraw();</PRE
>
                        This seems to speed up at least the linux version of Firefox considerably.                 
                </P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN172"
>8.3.3. Use memoizers</A
></H3
><P
>&#13;                        Common functions like binomial() and factorial() are realized with memoizer techniques, 
                        as descripted in <A
HREF="b189.html#AEN192"
><ABBR
CLASS="abbrev"
>Crockford2008</ABBR
></A
>, page 44.
                        Thus, the expensive computation of each value of these functions is done only once.
                 </P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN176"
>8.3.4. Distinguish mouse move and mouse up events</A
></H3
><P
>&#13;                    For curves there are two update modes, resulting in different quality in output. During the update following a
                    mouse move event, a curve is plotted evaluating only few data points. The default value here is to use 400 points.
                    In the update follwoing a mouse up event the same curve is plotted with much more points. The default value
                    now is to use 2000 points. These values can be adapted in Options.js.                 
                </P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN179"
>8.3.5. Reduce the download and initialization time</A
></H3
><P
>&#13;                    The JavaScript source code of 
                    JSXGraph version 0.76 consists of 20 individual files, which add up to about 980 kBytes including comments.
                    These 20 files are bundled together in one big file which is subsequently compressed by the 
                    YUI compressor<A
NAME="AEN182"
HREF="#FTN.AEN182"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
> from Yahoo!. 
                    During this process comments and superfluous whitespace are removed. The resulting file jsxgraphcore.js
                    only consists of 380 kBytes. If the web server which delivers jsxgraphcore.js has DEFLATE enabled, which means it
                    compresses its output additionally with gzip, the web browser has to download about 80 kByte. 
                    In most cases, this is less than the same construction would take as non-interactive PNG image.
                </P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="AEN185"
>8.3.6. An Internet Explorer trick</A
></H3
><P
>&#13;                    A very special, but decisive speed improvement has been done for the Internet Explorer version 6 and 7.  
                     With the following piece of code which is executed at initialization time the update speed of the Internet Explorer has been improved by an order of magnitude.
                <PRE
CLASS="programlisting"
>    
    function MouseMove(e) {
        document.body.scrollLeft;
        document.body.scrollTop;
    }
    document.onmousemove = MouseMove;</PRE
>
                    We are not aware that this trick has been mentioned before anywhere else.
                </P
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN140"
HREF="x136.html#AEN140"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
HREF="http://prototypejs.org"
TARGET="_top"
>http://prototypejs.org</A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN143"
HREF="x136.html#AEN143"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
HREF="http://jquery.com"
TARGET="_top"
>http://jquery.com</A
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN149"
HREF="x136.html#AEN149"
><SPAN
CLASS="footnote"
>[3]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>See <A
HREF="http://www.w3.org/TR/1998/NOTE-VML-19980513"
TARGET="_top"
>http://www.w3.org/TR/1998/NOTE-VML-19980513</A
> for the specification.</P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN182"
HREF="x136.html#AEN182"
><SPAN
CLASS="footnote"
>[4]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
><A
HREF="http://developer.yahoo.com/yui/compressor/"
TARGET="_top"
>http://developer.yahoo.com/yui/compressor/</A
></P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x133.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="b189.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Using JSXGraph with a connection to a server</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="t2.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Bibliography</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>